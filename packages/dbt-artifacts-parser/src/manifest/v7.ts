/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * WritableManifest(metadata: dbt.contracts.graph.manifest.ManifestMetadata, nodes: Mapping[str, Union[dbt.contracts.graph.compiled.CompiledAnalysisNode, dbt.contracts.graph.compiled.CompiledSingularTestNode, dbt.contracts.graph.compiled.CompiledModelNode, dbt.contracts.graph.compiled.CompiledHookNode, dbt.contracts.graph.compiled.CompiledRPCNode, dbt.contracts.graph.compiled.CompiledSqlNode, dbt.contracts.graph.compiled.CompiledGenericTestNode, dbt.contracts.graph.compiled.CompiledSeedNode, dbt.contracts.graph.compiled.CompiledSnapshotNode, dbt.contracts.graph.parsed.ParsedAnalysisNode, dbt.contracts.graph.parsed.ParsedSingularTestNode, dbt.contracts.graph.parsed.ParsedHookNode, dbt.contracts.graph.parsed.ParsedModelNode, dbt.contracts.graph.parsed.ParsedRPCNode, dbt.contracts.graph.parsed.ParsedSqlNode, dbt.contracts.graph.parsed.ParsedGenericTestNode, dbt.contracts.graph.parsed.ParsedSeedNode, dbt.contracts.graph.parsed.ParsedSnapshotNode]], sources: Mapping[str, dbt.contracts.graph.parsed.ParsedSourceDefinition], macros: Mapping[str, dbt.contracts.graph.parsed.ParsedMacro], docs: Mapping[str, dbt.contracts.graph.parsed.ParsedDocumentation], exposures: Mapping[str, dbt.contracts.graph.parsed.ParsedExposure], metrics: Mapping[str, dbt.contracts.graph.parsed.ParsedMetric], selectors: Mapping[str, Any], disabled: Union[Mapping[str, List[Union[dbt.contracts.graph.compiled.CompiledAnalysisNode, dbt.contracts.graph.compiled.CompiledSingularTestNode, dbt.contracts.graph.compiled.CompiledModelNode, dbt.contracts.graph.compiled.CompiledHookNode, dbt.contracts.graph.compiled.CompiledRPCNode, dbt.contracts.graph.compiled.CompiledSqlNode, dbt.contracts.graph.compiled.CompiledGenericTestNode, dbt.contracts.graph.compiled.CompiledSeedNode, dbt.contracts.graph.compiled.CompiledSnapshotNode, dbt.contracts.graph.parsed.ParsedAnalysisNode, dbt.contracts.graph.parsed.ParsedSingularTestNode, dbt.contracts.graph.parsed.ParsedHookNode, dbt.contracts.graph.parsed.ParsedModelNode, dbt.contracts.graph.parsed.ParsedRPCNode, dbt.contracts.graph.parsed.ParsedSqlNode, dbt.contracts.graph.parsed.ParsedGenericTestNode, dbt.contracts.graph.parsed.ParsedSeedNode, dbt.contracts.graph.parsed.ParsedSnapshotNode, dbt.contracts.graph.parsed.ParsedSourceDefinition]]], NoneType], parent_map: Union[Dict[str, List[str]], NoneType], child_map: Union[Dict[str, List[str]], NoneType])
 */
export interface HttpsSchemasGetdbtComDbtManifestV7Json {
  metadata: ManifestMetadata;
  /**
   * The nodes defined in the dbt project and its dependencies
   */
  nodes: {
    [k: string]:
      | CompiledAnalysisNode
      | CompiledSingularTestNode
      | CompiledModelNode
      | CompiledHookNode
      | CompiledRPCNode
      | CompiledSqlNode
      | CompiledGenericTestNode
      | CompiledSeedNode
      | CompiledSnapshotNode
      | ParsedAnalysisNode
      | ParsedSingularTestNode
      | ParsedHookNode
      | ParsedModelNode
      | ParsedRPCNode
      | ParsedSqlNode
      | ParsedGenericTestNode
      | ParsedSeedNode
      | ParsedSnapshotNode;
  };
  /**
   * The sources defined in the dbt project and its dependencies
   */
  sources: {
    [k: string]: ParsedSourceDefinition;
  };
  /**
   * The macros defined in the dbt project and its dependencies
   */
  macros: {
    [k: string]: ParsedMacro;
  };
  /**
   * The docs defined in the dbt project and its dependencies
   */
  docs: {
    [k: string]: ParsedDocumentation;
  };
  /**
   * The exposures defined in the dbt project and its dependencies
   */
  exposures: {
    [k: string]: ParsedExposure;
  };
  /**
   * The metrics defined in the dbt project and its dependencies
   */
  metrics: {
    [k: string]: ParsedMetric;
  };
  /**
   * The selectors defined in selectors.yml
   */
  selectors: {
    [k: string]: unknown;
  };
  /**
   * A mapping of the disabled nodes in the target
   */
  disabled?: {
    [k: string]: (
      | CompiledAnalysisNode
      | CompiledSingularTestNode
      | CompiledModelNode
      | CompiledHookNode
      | CompiledRPCNode
      | CompiledSqlNode
      | CompiledGenericTestNode
      | CompiledSeedNode
      | CompiledSnapshotNode
      | ParsedAnalysisNode
      | ParsedSingularTestNode
      | ParsedHookNode
      | ParsedModelNode
      | ParsedRPCNode
      | ParsedSqlNode
      | ParsedGenericTestNode
      | ParsedSeedNode
      | ParsedSnapshotNode
      | ParsedSourceDefinition
    )[];
  } | null;
  /**
   * A mapping fromÂ child nodes to their dependencies
   */
  parent_map?: {
    [k: string]: string[];
  } | null;
  /**
   * A mapping from parent nodes to their dependents
   */
  child_map?: {
    [k: string]: string[];
  } | null;
}
/**
 * Metadata about the manifest
 */
export interface ManifestMetadata {
  dbt_schema_version?: string;
  dbt_version?: string;
  generated_at?: string;
  invocation_id?: string | null;
  env?: {
    [k: string]: string;
  };
  /**
   * A unique identifier for the project
   */
  project_id?: string | null;
  /**
   * A unique identifier for the user
   */
  user_id?: string | null;
  /**
   * Whether dbt is configured to send anonymous usage statistics
   */
  send_anonymous_usage_stats?: boolean | null;
  /**
   * The type name of the adapter
   */
  adapter_type?: string | null;
}
/**
 * CompiledAnalysisNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledAnalysisNode".
 */
export interface CompiledAnalysisNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "analysis";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs1;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * FileHash(name: str, checksum: str)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "FileHash".
 */
export interface FileHash {
  name: string;
  checksum: string;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * Hook(sql: str, transaction: bool = True, index: Union[int, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "Hook".
 */
export interface Hook {
  sql: string;
  transaction?: boolean;
  index?: number | null;
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs {
  show?: boolean;
  node_color?: string | null;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn {
  macros?: string[];
  nodes?: string[];
}
/**
 * ColumnInfo(name: str, description: str = '', meta: Dict[str, Any] = <factory>, data_type: Union[str, NoneType] = None, quote: Union[bool, NoneType] = None, tags: List[str] = <factory>, _extra: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ColumnInfo".
 */
export interface ColumnInfo {
  name: string;
  description?: string;
  meta?: {
    [k: string]: unknown;
  };
  data_type?: string | null;
  quote?: boolean | null;
  tags?: string[];
  [k: string]: unknown;
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs1 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * InjectedCTE(id: str, sql: str)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "InjectedCTE".
 */
export interface InjectedCTE {
  id: string;
  sql: string;
}
/**
 * CompiledSingularTestNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledSingularTestNode".
 */
export interface CompiledSingularTestNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "test";
  alias: string;
  checksum: FileHash;
  config?: TestConfig;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn1;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs2;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
 */
export interface TestConfig {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  severity?: string;
  store_failures?: boolean | null;
  where?: string | null;
  limit?: number | null;
  fail_calc?: string;
  warn_if?: string;
  error_if?: string;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn1 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs2 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledModelNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledModelNode".
 */
export interface CompiledModelNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "model";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig1;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn2;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs3;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig1 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn2 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs3 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledHookNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None, index: Union[int, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledHookNode".
 */
export interface CompiledHookNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "operation";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig2;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn3;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs4;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
  index?: number | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig2 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn3 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs4 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledRPCNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledRPCNode".
 */
export interface CompiledRPCNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "rpc";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig3;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn4;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs5;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig3 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn4 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs5 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledSqlNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledSqlNode".
 */
export interface CompiledSqlNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "sql operation";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig4;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn5;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs6;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig4 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn5 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs6 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledGenericTestNode(test_metadata: dbt.contracts.graph.parsed.TestMetadata, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None, column_name: Union[str, NoneType] = None, file_key_name: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledGenericTestNode".
 */
export interface CompiledGenericTestNode {
  test_metadata: TestMetadata;
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "test";
  alias: string;
  checksum: FileHash;
  config?: TestConfig1;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn6;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs7;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
  column_name?: string | null;
  file_key_name?: string | null;
}
/**
 * TestMetadata(name: str, kwargs: Dict[str, Any] = <factory>, namespace: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "TestMetadata".
 */
export interface TestMetadata {
  name: string;
  kwargs?: {
    [k: string]: unknown;
  };
  namespace?: string | null;
}
/**
 * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
 */
export interface TestConfig1 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  severity?: string;
  store_failures?: boolean | null;
  where?: string | null;
  limit?: number | null;
  fail_calc?: string;
  warn_if?: string;
  error_if?: string;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn6 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs7 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledSeedNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SeedConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledSeedNode".
 */
export interface CompiledSeedNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "seed";
  alias: string;
  checksum: FileHash;
  config?: SeedConfig;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn7;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs9;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * SeedConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'seed', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, quote_columns: Union[bool, NoneType] = None)
 */
export interface SeedConfig {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs8;
  quote_columns?: boolean | null;
  [k: string]: unknown;
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs8 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn7 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs9 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * CompiledSnapshotNode(compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, compiled_code: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "CompiledSnapshotNode".
 */
export interface CompiledSnapshotNode {
  compiled: boolean;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "snapshot";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig5;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn8;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs10;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  compiled_code?: string | null;
  extra_ctes_injected?: boolean;
  extra_ctes?: InjectedCTE[];
  relation_name?: string | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig5 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn8 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs10 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedAnalysisNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedAnalysisNode".
 */
export interface ParsedAnalysisNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "analysis";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig6;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn9;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs11;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig6 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn9 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs11 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedSingularTestNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedSingularTestNode".
 */
export interface ParsedSingularTestNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "test";
  alias: string;
  checksum: FileHash;
  config?: TestConfig2;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn10;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs12;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
 */
export interface TestConfig2 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  severity?: string;
  store_failures?: boolean | null;
  where?: string | null;
  limit?: number | null;
  fail_calc?: string;
  warn_if?: string;
  error_if?: string;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn10 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs12 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedHookNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, index: Union[int, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedHookNode".
 */
export interface ParsedHookNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "operation";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig7;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn11;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs13;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  index?: number | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig7 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn11 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs13 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedModelNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedModelNode".
 */
export interface ParsedModelNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "model";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig8;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn12;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs14;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig8 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn12 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs14 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedRPCNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedRPCNode".
 */
export interface ParsedRPCNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "rpc";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig9;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn13;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs15;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig9 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn13 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs15 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedSqlNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedSqlNode".
 */
export interface ParsedSqlNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "sql operation";
  alias: string;
  checksum: FileHash;
  config?: NodeConfig10;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn14;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs16;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 */
export interface NodeConfig10 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn14 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs16 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedGenericTestNode(test_metadata: dbt.contracts.graph.parsed.TestMetadata, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>, column_name: Union[str, NoneType] = None, file_key_name: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedGenericTestNode".
 */
export interface ParsedGenericTestNode {
  test_metadata: TestMetadata;
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "test";
  alias: string;
  checksum: FileHash;
  config?: TestConfig3;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn15;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs17;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
  column_name?: string | null;
  file_key_name?: string | null;
}
/**
 * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
 */
export interface TestConfig3 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  severity?: string;
  store_failures?: boolean | null;
  where?: string | null;
  limit?: number | null;
  fail_calc?: string;
  warn_if?: string;
  error_if?: string;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn15 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs17 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedSeedNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SeedConfig = <factory>, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedSeedNode".
 */
export interface ParsedSeedNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "seed";
  alias: string;
  checksum: FileHash;
  config?: SeedConfig1;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn16;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs18;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * SeedConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'seed', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, quote_columns: Union[bool, NoneType] = None)
 */
export interface SeedConfig1 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs8;
  quote_columns?: boolean | null;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn16 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs18 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedSnapshotNode(database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, raw_code: str, language: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SnapshotConfig, _event_status: Dict[str, Any] = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: float = <factory>, config_call_dict: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedSnapshotNode".
 */
export interface ParsedSnapshotNode {
  database?: string | null;
  schema: string;
  fqn: string[];
  unique_id: string;
  raw_code: string;
  language: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  resource_type: "snapshot";
  alias: string;
  checksum: FileHash;
  config: SnapshotConfig;
  tags?: string[];
  refs?: string[][];
  sources?: string[][];
  metrics?: string[][];
  depends_on?: DependsOn17;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs20;
  patch_path?: string | null;
  compiled_path?: string | null;
  build_path?: string | null;
  deferred?: boolean;
  unrendered_config?: {
    [k: string]: unknown;
  };
  created_at?: number;
  config_call_dict?: {
    [k: string]: unknown;
  };
}
/**
 * SnapshotConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'snapshot', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, strategy: Union[str, NoneType] = None, target_schema: Union[str, NoneType] = None, target_database: Union[str, NoneType] = None, updated_at: Union[str, NoneType] = None, check_cols: Union[str, List[str], NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "SnapshotConfig".
 */
export interface SnapshotConfig {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs19;
  strategy?: string | null;
  target_schema?: string | null;
  target_database?: string | null;
  updated_at?: string | null;
  check_cols?: string | string[] | null;
  [k: string]: unknown;
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs19 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn17 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs20 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * ParsedSourceDefinition(fqn: List[str], database: Union[str, NoneType], schema: str, unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, source_name: str, source_description: str, loader: str, identifier: str, resource_type: dbt.node_types.NodeType, _event_status: Dict[str, Any] = <factory>, quoting: dbt.contracts.graph.unparsed.Quoting = <factory>, loaded_at_field: Union[str, NoneType] = None, freshness: Union[dbt.contracts.graph.unparsed.FreshnessThreshold, NoneType] = None, external: Union[dbt.contracts.graph.unparsed.ExternalTable, NoneType] = None, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, source_meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.SourceConfig = <factory>, patch_path: Union[pathlib.Path, NoneType] = None, unrendered_config: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, created_at: float = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedSourceDefinition".
 */
export interface ParsedSourceDefinition {
  fqn: string[];
  database?: string | null;
  schema: string;
  unique_id: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  source_name: string;
  source_description: string;
  loader: string;
  identifier: string;
  resource_type: "source";
  quoting?: Quoting;
  loaded_at_field?: string | null;
  freshness?: FreshnessThreshold | null;
  external?: ExternalTable | null;
  description?: string;
  columns?: {
    [k: string]: ColumnInfo;
  };
  meta?: {
    [k: string]: unknown;
  };
  source_meta?: {
    [k: string]: unknown;
  };
  tags?: string[];
  config?: SourceConfig;
  patch_path?: string | null;
  unrendered_config?: {
    [k: string]: unknown;
  };
  relation_name?: string | null;
  created_at?: number;
}
/**
 * Quoting(database: Union[bool, NoneType] = None, schema: Union[bool, NoneType] = None, identifier: Union[bool, NoneType] = None, column: Union[bool, NoneType] = None)
 */
export interface Quoting {
  database?: boolean | null;
  schema?: boolean | null;
  identifier?: boolean | null;
  column?: boolean | null;
}
/**
 * FreshnessThreshold(warn_after: Union[dbt.contracts.graph.unparsed.Time, NoneType] = <factory>, error_after: Union[dbt.contracts.graph.unparsed.Time, NoneType] = <factory>, filter: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "FreshnessThreshold".
 */
export interface FreshnessThreshold {
  warn_after?: Time | null;
  error_after?: Time | null;
  filter?: string | null;
}
/**
 * Time(count: Union[int, NoneType] = None, period: Union[dbt.contracts.graph.unparsed.TimePeriod, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "Time".
 */
export interface Time {
  count?: number | null;
  period?: ("minute" | "hour" | "day") | null;
}
/**
 * ExternalTable(_extra: Dict[str, Any] = <factory>, location: Union[str, NoneType] = None, file_format: Union[str, NoneType] = None, row_format: Union[str, NoneType] = None, tbl_properties: Union[str, NoneType] = None, partitions: Union[List[dbt.contracts.graph.unparsed.ExternalPartition], NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ExternalTable".
 */
export interface ExternalTable {
  location?: string | null;
  file_format?: string | null;
  row_format?: string | null;
  tbl_properties?: string | null;
  partitions?: ExternalPartition[] | null;
  [k: string]: unknown;
}
/**
 * ExternalPartition(_extra: Dict[str, Any] = <factory>, name: str = '', description: str = '', data_type: str = '', meta: Dict[str, Any] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ExternalPartition".
 */
export interface ExternalPartition {
  name?: string;
  description?: string;
  data_type?: string;
  meta?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * SourceConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
 */
export interface SourceConfig {
  enabled?: boolean;
  [k: string]: unknown;
}
/**
 * ParsedMacro(unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, macro_sql: str, resource_type: dbt.node_types.NodeType, tags: List[str] = <factory>, depends_on: dbt.contracts.graph.parsed.MacroDependsOn = <factory>, description: str = '', meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, arguments: List[dbt.contracts.graph.unparsed.MacroArgument] = <factory>, created_at: float = <factory>, supported_languages: Union[List[dbt.node_types.ModelLanguage], NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedMacro".
 */
export interface ParsedMacro {
  unique_id: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  macro_sql: string;
  resource_type: "macro";
  tags?: string[];
  depends_on?: MacroDependsOn;
  description?: string;
  meta?: {
    [k: string]: unknown;
  };
  docs?: Docs21;
  patch_path?: string | null;
  arguments?: MacroArgument[];
  created_at?: number;
  supported_languages?: ("python" | "sql")[] | null;
}
/**
 * MacroDependsOn(macros: List[str] = <factory>)
 */
export interface MacroDependsOn {
  macros?: string[];
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 */
export interface Docs21 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * MacroArgument(name: str, type: Union[str, NoneType] = None, description: str = '')
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "MacroArgument".
 */
export interface MacroArgument {
  name: string;
  type?: string | null;
  description?: string;
}
/**
 * ParsedDocumentation(unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, block_contents: str)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedDocumentation".
 */
export interface ParsedDocumentation {
  unique_id: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  block_contents: string;
}
/**
 * ParsedExposure(fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, type: dbt.contracts.graph.unparsed.ExposureType, owner: dbt.contracts.graph.unparsed.ExposureOwner, resource_type: dbt.node_types.NodeType = <NodeType.Exposure: 'exposure'>, description: str = '', label: Union[str, NoneType] = None, maturity: Union[dbt.contracts.graph.unparsed.MaturityType, NoneType] = None, meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.ExposureConfig = <factory>, unrendered_config: Dict[str, Any] = <factory>, url: Union[str, NoneType] = None, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, created_at: float = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedExposure".
 */
export interface ParsedExposure {
  fqn: string[];
  unique_id: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  type: "dashboard" | "notebook" | "analysis" | "ml" | "application";
  owner: ExposureOwner;
  resource_type?:
    | "model"
    | "analysis"
    | "test"
    | "snapshot"
    | "operation"
    | "seed"
    | "rpc"
    | "sql operation"
    | "docs block"
    | "source"
    | "macro"
    | "exposure"
    | "metric";
  description?: string;
  label?: string | null;
  maturity?: ("low" | "medium" | "high") | null;
  meta?: {
    [k: string]: unknown;
  };
  tags?: string[];
  config?: ExposureConfig;
  unrendered_config?: {
    [k: string]: unknown;
  };
  url?: string | null;
  depends_on?: DependsOn18;
  refs?: string[][];
  sources?: string[][];
  created_at?: number;
}
/**
 * ExposureOwner(email: str, name: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ExposureOwner".
 */
export interface ExposureOwner {
  email: string;
  name?: string | null;
}
/**
 * ExposureConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
 */
export interface ExposureConfig {
  enabled?: boolean;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn18 {
  macros?: string[];
  nodes?: string[];
}
/**
 * ParsedMetric(fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, description: str, label: str, calculation_method: str, expression: str, timestamp: Union[str, NoneType], filters: List[dbt.contracts.graph.unparsed.MetricFilter], time_grains: List[str], dimensions: List[str], window: Union[dbt.contracts.graph.unparsed.MetricTime, NoneType], model: Union[str, NoneType] = None, model_unique_id: Union[str, NoneType] = None, resource_type: dbt.node_types.NodeType = <NodeType.Metric: 'metric'>, meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.MetricConfig = <factory>, unrendered_config: Dict[str, Any] = <factory>, sources: List[List[str]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, refs: List[List[str]] = <factory>, metrics: List[List[str]] = <factory>, created_at: float = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ParsedMetric".
 */
export interface ParsedMetric {
  fqn: string[];
  unique_id: string;
  package_name: string;
  root_path: string;
  path: string;
  original_file_path: string;
  name: string;
  description: string;
  label: string;
  calculation_method: string;
  expression: string;
  timestamp?: string | null;
  filters: MetricFilter[];
  time_grains: string[];
  dimensions: string[];
  window?: MetricTime | null;
  model?: string | null;
  model_unique_id?: string | null;
  resource_type?:
    | "model"
    | "analysis"
    | "test"
    | "snapshot"
    | "operation"
    | "seed"
    | "rpc"
    | "sql operation"
    | "docs block"
    | "source"
    | "macro"
    | "exposure"
    | "metric";
  meta?: {
    [k: string]: unknown;
  };
  tags?: string[];
  config?: MetricConfig;
  unrendered_config?: {
    [k: string]: unknown;
  };
  sources?: string[][];
  depends_on?: DependsOn19;
  refs?: string[][];
  metrics?: string[][];
  created_at?: number;
}
/**
 * MetricFilter(field: str, operator: str, value: str)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "MetricFilter".
 */
export interface MetricFilter {
  field: string;
  operator: string;
  value: string;
}
/**
 * MetricTime(count: Union[int, NoneType] = None, period: Union[dbt.contracts.graph.unparsed.MetricTimePeriod, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "MetricTime".
 */
export interface MetricTime {
  count?: number | null;
  period?: ("day" | "week" | "month" | "year") | null;
}
/**
 * MetricConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
 */
export interface MetricConfig {
  enabled?: boolean;
  [k: string]: unknown;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 */
export interface DependsOn19 {
  macros?: string[];
  nodes?: string[];
}
/**
 * Metadata for the manifest.
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ManifestMetadata".
 */
export interface ManifestMetadata1 {
  dbt_schema_version?: string;
  dbt_version?: string;
  generated_at?: string;
  invocation_id?: string | null;
  env?: {
    [k: string]: string;
  };
  /**
   * A unique identifier for the project
   */
  project_id?: string | null;
  /**
   * A unique identifier for the user
   */
  user_id?: string | null;
  /**
   * Whether dbt is configured to send anonymous usage statistics
   */
  send_anonymous_usage_stats?: boolean | null;
  /**
   * The type name of the adapter
   */
  adapter_type?: string | null;
}
/**
 * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'view', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "NodeConfig".
 */
export interface NodeConfig11 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs;
  [k: string]: unknown;
}
/**
 * Docs(show: bool = True, node_color: Union[str, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "Docs".
 */
export interface Docs22 {
  show?: boolean;
  node_color?: string | null;
}
/**
 * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "DependsOn".
 */
export interface DependsOn20 {
  macros?: string[];
  nodes?: string[];
}
/**
 * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'test', severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "TestConfig".
 */
export interface TestConfig4 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  severity?: string;
  store_failures?: boolean | null;
  where?: string | null;
  limit?: number | null;
  fail_calc?: string;
  warn_if?: string;
  error_if?: string;
  [k: string]: unknown;
}
/**
 * SeedConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, meta: Dict[str, Any] = <factory>, materialized: str = 'seed', incremental_strategy: Union[str, NoneType] = None, persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, full_refresh: Union[bool, NoneType] = None, unique_key: Union[str, List[str], NoneType] = None, on_schema_change: Union[str, NoneType] = 'ignore', grants: Dict[str, Any] = <factory>, packages: List[str] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, quote_columns: Union[bool, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "SeedConfig".
 */
export interface SeedConfig2 {
  enabled?: boolean;
  alias?: string | null;
  schema?: string | null;
  database?: string | null;
  tags?: string[] | string;
  meta?: {
    [k: string]: unknown;
  };
  materialized?: string;
  incremental_strategy?: string | null;
  persist_docs?: {
    [k: string]: unknown;
  };
  "post-hook"?: Hook[];
  "pre-hook"?: Hook[];
  quoting?: {
    [k: string]: unknown;
  };
  column_types?: {
    [k: string]: unknown;
  };
  full_refresh?: boolean | null;
  unique_key?: string | string[] | null;
  on_schema_change?: string | null;
  grants?: {
    [k: string]: unknown;
  };
  packages?: string[];
  docs?: Docs8;
  quote_columns?: boolean | null;
  [k: string]: unknown;
}
/**
 * Quoting(database: Union[bool, NoneType] = None, schema: Union[bool, NoneType] = None, identifier: Union[bool, NoneType] = None, column: Union[bool, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "Quoting".
 */
export interface Quoting1 {
  database?: boolean | null;
  schema?: boolean | null;
  identifier?: boolean | null;
  column?: boolean | null;
}
/**
 * FreshnessMetadata(dbt_schema_version: str = <factory>, dbt_version: str = '1.3.0b2', generated_at: datetime.datetime = <factory>, invocation_id: Union[str, NoneType] = <factory>, env: Dict[str, str] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "FreshnessMetadata".
 */
export interface FreshnessMetadata {
  dbt_schema_version?: string;
  dbt_version?: string;
  generated_at?: string;
  invocation_id?: string | null;
  env?: {
    [k: string]: string;
  };
}
/**
 * SourceFreshnessRuntimeError(unique_id: str, error: Union[str, int, NoneType], status: dbt.contracts.results.FreshnessErrorEnum)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "SourceFreshnessRuntimeError".
 */
export interface SourceFreshnessRuntimeError {
  unique_id: string;
  error?: string | number | null;
  status: "runtime error";
}
/**
 * SourceFreshnessOutput(unique_id: str, max_loaded_at: datetime.datetime, snapshotted_at: datetime.datetime, max_loaded_at_time_ago_in_s: float, status: dbt.contracts.results.FreshnessStatus, criteria: dbt.contracts.graph.unparsed.FreshnessThreshold, adapter_response: Dict[str, Any], timing: List[dbt.contracts.results.TimingInfo], thread_id: str, execution_time: float)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "SourceFreshnessOutput".
 */
export interface SourceFreshnessOutput {
  unique_id: string;
  max_loaded_at: string;
  snapshotted_at: string;
  max_loaded_at_time_ago_in_s: number;
  status: "pass" | "warn" | "error" | "runtime error";
  criteria: FreshnessThreshold;
  adapter_response: {
    [k: string]: unknown;
  };
  timing: TimingInfo[];
  thread_id: string;
  execution_time: number;
}
/**
 * TimingInfo(name: str, started_at: Union[datetime.datetime, NoneType] = None, completed_at: Union[datetime.datetime, NoneType] = None)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "TimingInfo".
 */
export interface TimingInfo {
  name: string;
  started_at?: string | null;
  completed_at?: string | null;
}
/**
 * SourceConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "SourceConfig".
 */
export interface SourceConfig1 {
  enabled?: boolean;
  [k: string]: unknown;
}
/**
 * MacroDependsOn(macros: List[str] = <factory>)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "MacroDependsOn".
 */
export interface MacroDependsOn1 {
  macros?: string[];
}
/**
 * ExposureConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "ExposureConfig".
 */
export interface ExposureConfig1 {
  enabled?: boolean;
  [k: string]: unknown;
}
/**
 * MetricConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
 *
 * This interface was referenced by `HttpsSchemasGetdbtComDbtManifestV7Json`'s JSON-Schema
 * via the `definition` "MetricConfig".
 */
export interface MetricConfig1 {
  enabled?: boolean;
  [k: string]: unknown;
}
